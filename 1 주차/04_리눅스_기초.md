# 1주차 내용 정리: 리눅스 기초

### 목차
1. [리눅스의 세계로](#✅-1-리눅스의-세계로)
2. [리눅스 파일 시스템](#✅-2-리눅스-파일-시스템)
3. [알고 쓰는 리눅스 명령어](#✅-3-알고-쓰는-리눅스-명령어)
4. [프로세스와 네트워크](#✅-4-프로세스와-네트워크)

---

# ✅ 1. 리눅스의 세계로
## 📌 리눅스 소개
### 리눅스란?
리눅스는 리누스 토발즈(Linus Torvalds)가 만든 오픈 소스 운영체제입니다.

- 오픈 소스이며 누구나 자유롭게 수정하고 배포할 수 있음
- 대표적인 자유 소프트웨어로, 많은 서버와 시스템에서 사용됨

> 우리가 접속하는 많은 웹사이트들도 백그라운드에서 리눅스로 돌아가고 있습니다!

## 📌 리눅스의 특징 및 종류
- 유닉스 기반으로 만들어짐
- 멀티 유저: 여러 사용자가 동시에 사용 가능
- 멀티 태스킹: 여러 작업을 동시에 처리 가능
- CLI + GUI 지원: 명령어 기반 환경과 그래픽 환경 모두 사용 가능
- 강력한 네트워크 기능: 서버 운영에 최적화

> 개발자나 서버 관리자는 CLI(터미널)로 리눅스를 조작하는 것을 더 선호합니다!

### 배포판 종류

| 배포판 | 특징 |
|--------|------|
| **Ubuntu** | 초보자도 쓰기 쉬운 데스크탑용 배포판 |
| **CentOS** | 서버 운영에 자주 사용되는 안정적인 배포판 |
| **Debian** | 우분투의 기반이 되는 배포판, 패키지 관리가 안정적 |

### 활용 분야
- 네트워크 서버 장비
- 리눅스 개발 서버
- 안드로이드
- 개인 PC
- 블랙박스 등

## 📌 리눅스 기초 명령어
Shell(셸)을 통해서 Kernel(커널)에 명령을 요청합니다.

- Shell의 종류: Bash, Sh, csh, Ksh 등
- 리눅스의 기본 Shell은 Bash입니다.

### whoami
```bash
elicer ~$ whoami
> elicer
```
➡️ 로그인한 사용자 ID를 알려주는 명령어

### passwd
```bash
elicer ~$ passwd
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
```
➡️ 현재 로그인한 사용자 비밀번호 변경

### pwd
```bash
elicer ~$ pwd
/elicer/currentDirectory
```
➡️ 현재 디렉토리 위치를 출력

### ls
```bash
elicer ~$ ls
elice_dir main.py conf.d try.sh
```
➡️ 현재 디렉토리의 목록을 출력

### ls -a
```bash
elicer ~$ ls -a
.   .cash   .profile    바탕화면
..  .config  공개        비디오
```
➡️ 숨겨진 파일이나 디렉토리를 포함하여 출력

### ls -al
```bash
elicer ~$ ls -al
drwxr-xr-x 1 elicer elicer   21 Sep 10 09:22 .
drwxr-xr-x 1 elicer elicer   26 Sep 10 09:42 ..
-rw-r--r-- 1 elicer eclier 4096 Mar 19 17:15 .cash
```
➡️ 숨겨진 파일과 디렉토리를 포함해 현재 디렉토리의 목록을 상세히 출력

### cd
```bash
elicer~$ cd my_project
elicer~/my_project$ 
```
➡️ 해당 디렉토리로 이동

## 📌 GUI vs CLI
### GUI (Graphical User Interface)
`Graphical User Interface`의 약자로 사용자가 편리하게 사용할 수 있도록 기능을 아이콘, 이미지 등의 `그래픽`으로 나타낸 `인터페이스`

➡️ Windows와 Mac 운영체제 모두 GUI 사용

### CLI (Command Line Interface)
`Command Line Interface`의 약자로 `문자를 통해서` 사용자와 컴퓨터가 상호작용하여 동작하는 `인터페이스`

➡️ Windows의 CMD, Mac의 Terminal은 CLI를 사용

# ✅ 2. 리눅스 파일 시스템
## 📌 리눅스 파일 시스템 개념
저장 장치 내에서 데이터를 읽고 쓰기 위해 미리 정한 약속입니다.

- `디렉토리(Directories)` + `파일(File)` 형태로 구성
- `루트` 파일 아래에 `계층적`으로 모든 파일과 디렉토리가 만들어짐

### 파일
주기억장치나 디스크와 같은 물리적인 `하드웨어`이며 저장 공간에 저장되는 `데이터의 집합`

### 디렉토리
`파일`과 `하위 디렉토리`들을 그룹으로 묶은 개념

## 📌 디렉토리의 구조
```
root
├── bin
├── etc
├── user
├── home
│   ├── elice
│   │   ├── 바탕화면
│   │   ├── 문서
│   │   ├── 다운로드
```
리눅스 파일 시스템의 디렉터리 구조는 트리(tree) 구조입니다.

> `tree` 명령문을 통해 확인 가능합니다.

## 📌 소유권과 권한
`ls -al` 명령어를 통해 파일 속성을 확인할 수 있습니다.

### 파일 속성
```
- rw-r--r-- 1 elice elice 8980 9월 16 09:35 elice.txt
```

|항목|설명|
|-------|----------|
|-|파일 유형: -는 일반 파일을 의미함|
|rw-r--r--|파일 권한: 사용자/그룹/기타의 접근 권한 표시|
|1|하드 링크 수: 해당 파일을 참조하는 링크 수|
|elice|파일 소유자: 파일을 만든 사용자 이름|
|elice|파일 소유 그룹: 소유자가 속한 그룹 이름|
|8980|파일 크기: 바이트(byte) 단위 크기|
|9월 16 09:35|최종 수정 시간: 파일이 마지막으로 수정된 날짜와 시간|
|elice.txt|파일 이름: 실제 파일의 이름|

### 파일의 권한 
- `r` = 4 (읽기)
- `w` = 2 (쓰기)
- `x` = 1 (실행)
- `-` = 0 (권한 없음)
```
rw-r--r-- 을 숫자로 표현하면

rw- = 4 + 2 + 0 = 6
r-- = 4 + 0 + 0 = 4
r-- = 4 + 0 + 0 = 4

3자리씩 끊어서 표현: 644
```

### 파일의 권한 변경
```bash
chmod [파일권한] [변경할 파일 위치 또는 이름]
```

파일 권한은 읽기(4), 쓰기(2), 실행(1), 없음(0)으로 숫자로 표현

`777 권한`은 모든 사용자가 모든 권한을 얻는다는 의미

### 파일 소유권 변경
```bash
chown [소유할 유저]:[소유할 그룹] [소유권 변경하고 싶은 디렉토리 or 파일 명]
```

`root` 권한이 있어야 실행 가능

## 📌 파일 관련 명령어

### mkdir (디렉토리 생성)
```bash
mkdir [생성할 디렉토리 이름]
``` 

현재 디렉토리 위치에 새로운 디렉토리 생성

```bash
mkdir [디렉토리 경로/디렉토리명]
```
특정 경로에 디렉토리 생성 가능

### touch (파일 생성)
```bash
touch [생성할 파일 이름]
```
`빈 파일`을 생성합니다.

### rmdir (디렉토리 삭제)
```bash
rmdir [삭제할 디렉토리 이름]
```
`비어있는` 디렉토리를 삭제

디렉토리에 `파일`이 있을 경우 `삭제 불가능`

### rm (파일/디렉토리 삭제)
```bash
rm [option] [삭제할 파일 및 디렉토리 명]
```
**주요 옵션**
- `-r` : 디렉토리와 그 하부 파일까지 삭제
- `-f` : 강제 삭제
- `-i` : 삭제할지 확인 후 삭제
- `-rf` : 강제로 하부 파일까지 삭제

### cp (복사)
```bash
cp [option] [대상 위치 및 이름] [복사하고 싶은 위치]
```

**주요 옵션**
- `-r` : 하위 디렉토리와 파일 전체 복사
- `-p` : 소유주, 그룹, 권한, 시간 정보를 그대로 복사

### mv (이동/이름 변경)
```bash
mv [대상 위치/이름] [이동하고 싶은 위치/이름]
```
이동하고 싶은 위치에 같은 이름의 파일/디렉토리 명이 존재하지 않을 경우 이동

### cat (파일 내용 출력)
```bash
cat [option] [파일 이름]
```

**주요 옵션**
- `-n` : 왼쪽에 줄 번호와 함께 내용을 출력
- `>` : 파일의 내용을 덮어 씀
- `>>` : 파일의 내용이 있다면 뒤에 내용을 추가

### find (파일 검색)
```bash
find [파일 경로] [-name] [파일 이름] [-type d/f]
```
지정된 [파일 경로]에서 이름이 [파일 이름]인 파일 및 디렉토리를 검색하는 명령어

> 명령어 도움말 확인: [사용하려는 명령어] --help

# ✅ 3. 알고 쓰는 리눅스 명령어
## 📌 정규표현식
정규 표현식(Regular expression)은 `특정한 규칙`을 가진 `문자열의 집합`을 표현하는데 사용하는 형식입니다.

### 정규표현식 문법
특정 문자들은 특정한 논리적 관계를 나타내는 기호이며 이를 제외한 나머지는 일반적인 문자를 뜻함

### 정규식 메타 문자

| 메타 문자 | 의미 설명 |
|-----------|-------------------------------------------|
| `^`       | 문자열의 시작을 의미 |
| `$`       | 문자열의 끝을 의미 |
| `.`       | 줄바꿈 문자를 제외한 모든 문자와 매칭 |
| `\s`      | 공백 문자 (스페이스, 탭, 줄바꿈 등) |
| `\S`      | 공백 문자를 제외한 모든 문자 |
| `\\`      | 역슬래시 자체 (`\`를 문자로 인식) |
| `\d`      | 숫자 (0~9) 하나와 매칭 |
| `\D`      | 숫자가 아닌 문자와 매칭 |
| `\w`      | 문자, 숫자, 언더스코어 (`[a-zA-Z0-9_]`) |
| `\W`      | 문자, 숫자, 언더스코어가 아닌 문자 |
| `\n`      | 줄바꿈 (newline) 문자 |
| `\t`      | 탭 문자 |

### 선택 패턴
`|` 문자를 이용하면 `A|B` 의 패턴으로 매칭 가능합니다.  
예: `alice|elice`는 "alice"와 "elice" 라는 문자열을 모두 포함

### 문자 클래스
- `[]` 대괄호 속에 넣은 문자 중에서 하나에 매칭
- `[0-9]` 0부터 9까지의 숫자 하나에 매칭
- `[A-Z]` A부터 Z까지의 알파벳 대문자 하나에 매칭

`[]` 내에서 `^` 기호는 not의 의미를 가집니다.

### 수량 한정자 

| 수량 한정자 | 의미 설명 |
|-------------|--------------------------------------------------------|
| `?`         | 앞의 문자가 **0개 또는 1개** 있을 때 매칭 |
| `*`         | 앞의 문자가 **0개 이상** 있을 때 매칭 (없어도 됨) |
| `+`         | 앞의 문자가 **1개 이상** 있을 때 매칭 (하나 이상 필수) |
| `{n}`       | 앞의 문자가 **정확히 n개** 있을 때 매칭 |
| `{n, m}`    | 앞의 문자가 **n개 이상 m개 이하** 있을 때 매칭 |
| `{n,}`      | 앞의 문자가 **n개 이상** 있을 때 매칭 |

### 그룹 패턴
괄호 `()`는 정규표현식에서 **"묶기"** 역할을 합니다.  
**한 덩어리로 인식해서** 나중에 다시 **참조하거나 반복**할 수 있습니다.

**핵심 개념**
- `( )`로 감싸면 **하나의 그룹**으로 만들어짐
- 그룹은 정규식 내에서 **번호(1번, 2번...)로 참조** 가능
- 그룹에 들어간 내용이 **나중에 또 반복되는지 확인**할 때 유용

**그룹 예시**
```
(to)ma\1  # toma가 매칭됨
```

### 정규 표현식 사용 예
전화번호 패턴 매칭 예시:
1. 전화번호는 010으로 시작
2. 전화번호의 가운데 자리는 네 자리
3. 전화번호의 각 자리에 구분 문자가 있을 수도 있고, 없을 수도 있음

> 패턴: ^010(\D?\d{4}){2}

- `^` : 시작 문자는 010
- `\D?` : 숫자가 아닌 문자가 0개 또는 1개
- `\d{4}` : 숫자가 4개
- `(\D?\d{4}){2}` : 앞의 그룹이 2개 존재

## 📌 리다이렉션
### 표준 스트림
컴퓨터 프로그램과 그 외부에 연결된 입출력 통로입니다.

### 정의
방향을 바꾼다는 뜻으로 표준 입력/출력의 흐름을 변경하는 기능을 의미합니다. 기본적으로 터미널에 출력되는 데이터를 파일로 저장하거나 다른 명령어로 전달할 수 있습니다.

### 출력 리다이렉션
- **'>'** : 기존 파일을 덮어 씀
- **'>>'** : 기존 파일에 내용을 추가함

```bash
echo "hello" > test.txt   # test.txt에 "hello"를 입력 (덮어쓰기)
echo "world" >> test.txt  # test.txt에 "world" 추가 (덮어쓰기 X)
```

### 입력 리다이렉션
- **'<'** : 파일에서 데이터를 읽어서 명령어의 입력으로 사용
- **'<<'** : 여러줄의 입력을 명령어에 전달

```bash
sort < test.txt  # test.txt의 내용을 정렬하여 출력
cat << EOF > test.txt
hello
world
EOF  # 여러 줄을 test.txt에 EOF 나올때까지 입력 받아 저장
```

## 📌 grep 명령어
grep 명령은 파일 내에서 지정한 패턴이나 문자열을 찾은 후에 그 패턴을 포함하고 있는 모든 행을 출력합니다.

```bash
grep [option] [pattern] [파일명]
```

**주요 옵션**
- `-i` : 대소문자를 구분하지 않고 검색
- `-v` : 패턴과 일치하지 않는 행을 출력
- `-c` : 패턴과 일치하는 행의 개수를 출력
- `-w` : 패턴과 단어 단위로 매칭되어야 출력

**예시**
```bash
grep elice hello.txt  # 'elice'라는 문자열이 들어 있는 행을 모두 출력
grep -c elice hello.txt  # 'elice'라는 문자열이 들어있는 행의 수 출력
grep [0-9] hello.txt  # 숫자가 존재하는 행을 모두 출력
grep "Elice\.The\.Rabbit" *  # 모든 파일에서 Elice.The.Rabbit 검색
```

## 📌 파일 리다이렉션
File Redirection은 표준 스트림의 흐름을 바꾸어 일반적인 표준 입력 및 출력, 그리고 오류를 사용하지 않고 다른 경로인 파일로 재지정하는 것을 뜻합니다.

### 표준 스트림
일반적으로 표준 입력, 표준 출력, 표준 오류 출력으로 분류되며, 스트림은 문자열로 콘솔에 출력되도록 설정되어 있습니다.

- `stdin` (0) : 키보드 입력
- `stdout` (1) : 화면 출력
- `stderr` (2) : 오류 내용 출력

표준 오류는 파일 디스크립터 번호를 `>` 앞에 작성해서 사용합니다.

## 📌 Pipe 명령어
### Linux Pipe
Pipe는 둘 이상의 명령어를 묶어 출력의 결과를 다른 명령으로 전환할 수 있는 기능입니다.

- 명령어의 표준 출력을 다른 명령어의 표준 입력으로 연결
- `|` 기호를 사용하여 명령어와 명령어를 연결

**예시**
```bash
head a.txt | grep [0-9]
```
1. head 명령을 실행하여 a.txt의 첫 10줄을 출력
2. 출력된 결과를 | (pipe)를 통해 grep 명령으로 전달
3. 숫자가 포함된 행만 출력

## 📌 마운트
### 마운트 (mount)
mount란 물리적인 저장 장치(보조기억장치)를 디렉토리(또는 폴더)에 연결시켜 주는 것을 말합니다.

윈도우에서는 하드, USB 등의 보조기억장치를 연결하면 자동으로 폴더에 연결됩니다 (Plug and Play). 반면 리눅스는 직접 연결해야 합니다.

```bash
mount [option] [device] [directory]
```

**주요 옵션**
- `-a` : /etc/fstab에 명시된 파일 시스템을 마운트
- `-t` : 파일 시스템의 유형을 지정
- `-o` : 추가적인 설정을 적용

```bash
umount [device] [directory]  # 마운트 해제 명령어
df  # 현재 마운트된 디스크 정보 출력
```

# ✅ 4. 프로세스와 네트워크
## 📌 프로세스 개념
리눅스 시스템에서 메모리에 적재되어 실행되고 있는 모든 프로그램이 프로세스입니다.

### 특징
1. 모든 프로그램은 하나 이상의 프로세스를 갖고 실행
2. 병행적으로 실행 가능
3. 부모-자식 프로세스 관계 존재
4. 커널에 의해 관리
5. 모든 프로세스에는 소유자가 있음
6. 프로세스마다 식별을 위한 ID가 부여

### 프로세스 번호
- PID 1번은 시스템 초기화 담당하는 `init` 또는 `systemd` 프로세스
- PID 2번은 보통 `kthreadd`이며, 커널 스레드 생성을 담당

> init 프로세스는 나머지 모든 시스템 프로세스의 부모 프로세스
> kthreadd 프로세스는 모든 스레드의 부모 프로세스

### 프로세스의 메모리 구성
1. **코드 영역**: 프로그램 코드
2. **데이터 영역**: 전역 변수와 정적 변수
3. **BSS 영역**: 초기화되지 않은 변수
4. **힙 영역**: 동적인 메모리 할당 영역
5. **스택 영역**: 함수 매개변수, 복귀 주소, 지역 변수와 같은 임시 자료
6. **커널**: kernel

## 📌 프로세스 관련 명령어
### ps (프로세스 목록 보기)
```bash
ps [option]
```

**주요 옵션**
- `-e` : 현재 실행 중인 모든 프로세스 정보 출력 
- `-f` : 모든 정보 확인
- `-a` : 실행중인 전체 사용자의 모든 프로세스 출력
- `-u` : 프로세스를 실행한 사용자와 프로세스 시작 시간 등 출력
- `-x` : 터미널 제어 없이 프로세스 현황 보기

> 옵션을 합쳐서 사용 가능 (예: ps -aux)

### kill (프로세스 종료)
```bash
kill [option] [PID:프로세스 아이디]
```

**주요 옵션**
- `-l` : 사용 가능한 시그널 목록 출력

**자주 사용하는 시그널**
- `-1` : 재실행(SIGHUP)
- `-9` : 강제종료(SIGKILL)
- `-15` : 정상 종료(SIGTERM)

## 📌 job
job 명령어는 현재 터미널에서 백그라운드로 실행 중인 작업 목록을 확인할 때 사용합니다.

### 핵심 개념
1. job은 **현재 쉘(터미널 세션)**에서 실행한 백그라운드 작업을 추적
2. 이 명령어는 터미널에서 실행된 작업만 보여줌 (다른 터미널의 작업은 보이지 않음)
3. 터미널을 종료하면, 해당 터미널에서 실행한 백그라운드 작업(job)도 함께 종료됨
4. 각 터미널마다 자기만의 job 리스트를 가짐