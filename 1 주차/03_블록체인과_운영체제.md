# 1주차 내용 정리

### 목차
1. [운영체제 소개](#1-운영체제_소개)
2. 

블록체인 내용은 스킵합니다.


# 1. 운영체제 소개
## 🌐 운영체제란
하드웨어를 포함한 리소스를 제어하고 프로그램을 실행해주는 시스템 소프트웨어


### 💡 필요성
- 사장이 혼자서 모든 직원을 이해하고 통제할 수 없음
- 사장과 직원 간의 소통이 필요함

### 리소스 
**resouce : 자원, 자산, 리소스**
- 자원의 사전적 의미 : 어떤 목적에 이용할 수 있는 물자나 인재

- 컴퓨터에서의 자원 : 어떤 목적에 이용할 수 있는 하드웨어를 포함한 모든 것

> 각 응용프로그램마다 할당된 리소스가 있음

## ⚙️ 운영체제의 기능
- 다음과 같은 기능을 포함합니다
```
1. 프로세스 관리 (프로그램 실행, 스케줄링, 동기화 등)

2. 메모리 관리 (프로그램이 사용하는 메모리 할당/해제 등)

3. 파일 시스템 관리 (데이터 저장/탐색/권한 등)

4. 입출력 장치 제어 (프린터, 키보드, 디스크 등 하드웨어 관리)

5. 사용자 인터페이스 제공 (CLI 또는 GUI 등)
```


### 프로세스 관리
```
프로세스는 실행 중인 프로그램(program)
```

- 리소스 관리 : 프로세스에게 필요한 리소스를 할당하는 기능
- 프로세스 상태관리 : 각 프로세스의 상태를 관리하는 기능
- 멀티 프로세싱 : 동시에 여러 프로세스를 실행하는 기능


### 메모리 관리
```
CPU에서 실행될 수 있도록 메모리에 정보를 올리거나 내림
```

- 메모리 관리 : 메모리에 프로그램을 올리고 프로세스에게 필요한 메모리를 할당함
- 가상 메모리 : 실제 메모리가 적더라도 프로세스를 실행할 수 있도록 도와주는 기술


#### 가상 메모리
```
실제 주소가 아닌 가상의 주소로 메모리를 관리한다
```
- 정보 보호 : 프로세스가 실제 주소를 모르기에 메모리 주소를 악용한 침범이 불가능
- 연속주소 제공 : 프로세스가 보는 주소는 연속된 주소로 처리할 수 있어서 효율적인 처리가 가능


### 파일 시스템 관리
```
어떤 방식을 사용하던지 프로그램에서 고민하지 않고 읽고 쓰게 해주는 기능
```
- 파일 시스템 : 저장 장치에 파일을 읽고 쓰는 방법

### 네트워크 관리
```
프로토콜을 지원하여 통신이 가능하도록 함
```

- 다양한 프로토콜을 지원하여 프로그램이 네트워크를 사용할 수 있도록 함
- 포트를 관리하여 이미 사용중인 포트는 사용할 수 없도록 제어

## 🧩 운영체제 종류

### Windows (윈도우)
- 마이크로소프트에서 개발한 운영체제
- GUI 기반의 운영체제
- 다양한 응용 프로그램을 지원함
- 가장 많이 사용되는 운영체제 중 하나


### MacOS (맥)
- 유닉스를 기반으로 Apple 사에서 제작한 데스크탑 운영체제
- 유닉스 계열의 터미널 명령어를 사용할 수 있어 개발 환경에 적합
- 돈을 주고 사야 하는 상용 소프트웨어


### Linux (리눅스)
- 무료에 안정적인 운영체제로 개발 및 서버에 적합한 운영체제
- 오픈 소스로 기업 또는 개인이 자신만의 운영체제로 수정하고 판매 가능
- 우분투, 데비안과 같은 다양한 계열의 배포판이 있으며 안드로이드도 리눅스를 기반으로 개발됨


### 컨테이너화
>Docker

- 실행에 필요한 모든 환경과 패키지를 포함하여 하나로 묶는 기술
- 내가 사용하는 운영체제에 상관없이 동일한 개발환경을 구성할 수 있음

# 2. 프로세스
## 프로세스의 개념
### 프로세스 (process)란?
> 실행중인 프로그램


### 프로그램 (program)이란?
> 특정 작업을 수행하는 명령어들의 모음

- 특정 작업을 수행하는 명령어들의 모음인 프로그램이 실행되면 프로세스


### 스레드 (Thread)란?
> 프로세스 안에서 실행되는 흐름 단위

- 프로세스에는 하나 이상의 스레드가 존재한다.


### 프로세스 vs 스레드
> 프로세스는 독립적인 메모리를 할당 받는다.

> 스레드는 프로세스의 메모리를 공유한다.

```
프로그램이 실행되면 운영체제는 해당 프로그램을 위한 프로세스를 생성한다.
그리고 프로세스는 기본적으로 하나 이상의 스레드를 포함하며, 실행 시 최소한 메인 스레드(Main Thread) 하나가 생성된다.
```

## 프로세스의 구조
| |설명|
|---|---|
|스택 (Stack)|임시 데이터(함수 호출, 로컬 변수 등)이 저장되는 영역|
|힙 (Heap)|동적으로 할당된 메모리 영역|
|데이터 (Data)|전역 변수, 정적 변수 등이 저장되는 영역|
|코드 (Code)|실행할 명령어들이 저장되는 영역|

### 코드 (Code) 영역
- 실행할 명령어들이 저장되는 영역

#### 정적 vs 동적
- 정적 : 변하지 않는다. (실행 중에 변하지 않는다.)
- 동적 : 변한다. (실행 중에 변한다.)


#### 정적 할당과 동적 할당
|정적 할당|동적 할당|
|---|---|
|실행 전에 미리 메모리를 할당한다.|실행 도중에 메모리를 할당한다.|
|할당받을 크기가 미리 정해져 있다.|실행 도중에 할당 받을 크기가 변할 수 있다.|


#### 예시
> 정적 할당

- 미리 최대 오프라인 사용자 수를 정해놓고 그만큼의 메모리를 할당한다.


> 동적 할당
- 학생 수가 늘어남에 따라 메모리를 할당한다.


### 데이터 (Data) 영역
- 전역 변수, 정적 변수 등이 저장되는 영역
- 프로그램이 시작될 때 할당되고 종료될 때 해제됨
- 프로그램이 종료될 때까지 유지됨


### 힙 (Heap) 영역
- 동적으로 할당된 메모리 영역
- 사용자가 직접 관리할 수 있는 메모리 영역
- 상대적으로 느리며 관리를 잘못할 경우 메모리 누수가 발생


### 스택 (Stack) 영역
- 함수의 호출과 관련된 지역 변수와 매개변수가 저장됨
- 함수가 호출될 때마다 스택에 쌓이고, 함수가 종료되면 스택에서 제거됨
- 스택은 LIFO(Last In First Out) 구조로, 가장 나중에 들어온 데이터가 가장 먼저 나감



## 프로세스의 상태
> 프로세스는 실행 중에 여러 상태를 가질 수 있다.

| 상태(State)         | 설명                                                         |
|----------------------|--------------------------------------------------------------|
| **New**              | 프로세스가 생성 중인 상태. 아직 준비 상태에 진입하지 않음         |
| **Ready**            | 실행될 준비가 된 상태. CPU 할당을 기다리는 대기 상태               |
| **Running**          | 현재 CPU를 할당받아 명령어를 실행 중인 상태                       |
| **Waiting (Blocked)**| 입출력(I/O) 등의 이벤트를 기다리며 일시 중단된 상태               |
| **Terminated**       | 실행이 끝나 종료된 상태                                        |

> 참고: 프로세스는 `New → Ready → Running → Terminated`로 흐르며, `Running ↔ Ready`, `Running → Waiting → Ready` 형태로 상태 전이가 발생할 수 있다.


### 생성(new/created)
> 번호표를 들고 식당밖에서 대기하는 단계

- 준비(Ready) 상태로의 승인을 기다리는 단계
- 아직 메모리에 로드되지 않은 상태


### 준비(ready)
> 식당에 들어가서 앉아 있는 상태

- 프로세스가 CPU를 사용하고 있진 않지만, 언제든 실행 될 수 있도록 대기하는 상태
- 우선순위가 높은 순서대로 CPU를 할당받음


### 실행(running)
> 나온 요리를 먹는 단계

- CPU가 할당되어 프로세스의 명령어들을 처리해주는 단계
- 동시에 다른 프로세스들을 처리하기 위해서 일정 시간 이후 다시 Ready 상태로 전이함


### 대기(Blocked/Waiting)
> 화장실 다녀오는 상태

- 프로세스가 특정 자원이나 이벤트를 기다리는 상태
- 입출력 완료 등 특정 이벤트를 기다리는 상태
- 이벤트가 완료되면 다시 Ready 상태로 전이함


### 종료(Terminated)
> 일어나서 나갈 준비를 하는 단계

- 모든 명령어가 완료된 상태
- 부모 프로세스가 상태를 확인하기 위해 바로 삭제되지 않고 이 상태에서 대기
- 이 상태가 끝나면 프로세스가 메모리에서 삭제됨


## 멀티 프로세싱
### 멀티 프로세싱 (Multi processing)
```
여러 개의 프로세스를 돌아가면서 조금씩 처리
```

### 스레드 (Thread)
> 프로세스 안에서 실행되는 흐름 단위

- 프로세스에는 하나 이상의 스레드가 존재한다.

### 멀티 스레드
- 한 프로세스 내에서 자원을 공유하면서 여러 작업을 처리
- 새로 프로세스를 생성하고 리소스를 할당받는 과정이 없어서 더 빠르게 처리가 가능
- 하나의 스레드가 문제가 생기면 프로세스 전체가 종료될 수 있음

> 한 집에서 동시에 빨래, 청소, 요리 하기

### 멀티 프로세스
> 여러 집에서 동시에 빨래, 청소, 요리 하기


### 프로세스간 통신(Inter Process Communication, IPC)
> 다른 집과 접시 효율적으로 주고 받기

- 다른 프로세스의 리소스는 절대 침범하면 안됨
- 운영체제가 허용하는 방법내에서 데이터를 주고 받는 방법들

1. 메시지 큐
- 공용 우편함에 넣어두기
- 데이터를 넣어두고 다른 프로세스들이 사용할 수 있게 하는 방법

2. 공유 메모리
- 현관문 열어두기
- 프로세스의 메모리 일부를 공유 메모리로 만들어 다른 프로세스와 공유하는 방법

3. 소켓
- 택배로 접시 보내기
- 소켓을 생성하여 다른 양방향 통신을 통해 데이터를 전달


## 프로세스 스케줄링
### 프로세스 스케줄링 (Process Scheduling)
> 어떤 손님부터 음식을 해줄 것인가

- 대기 시간은 가능한 최소화
- 가능한 공평하게 프로세스를 처리하는 것이 목적


### 🔄 주요 스케줄링 알고리즘

| 알고리즘                      | 설명 |
|-------------------------------|------|
| **선입선처리 FCFS (First Come First Serve)** | 먼저 온 프로세스를 먼저 처리. 간단하지만 대기 시간이 길어질 수 있음 (convoy effect 발생 가능) |
| **최단 작업 우선 SJF (Shortest Job First)**     | 수행 시간이 가장 짧은 프로세스를 먼저 처리. 평균 대기 시간이 짧지만, 긴 작업이 계속 밀릴 수 있음 (기아 상태 발생 가능) |
| **라운드 로빈 RR (Round Robin)**            | 각 프로세스에 동일한 시간 할당량(quantum)을 주고 순환하며 실행. 공평성 보장, 응답 시간이 짧아짐 |



## 교착 상태와 기아상태
### 교착 상태 (Deadlock)
```
회사 : 경력 없네? 안 뽑아! 경력 쌓아서 와!


신입 개발자 : 일을 해야 경력을 쌓지!
```
- 프로세스가 서로 상대방의 작업이 끝나기 만을 기다리고 있는 상태


#### 💣 교착 상태 발생 조건

| 조건 이름        | 설명 |
|------------------|------|
| **상호 배제 (Mutual Exclusion)** | 하나의 자원을 동시에 여러 프로세스가 사용할 수 없음 |
| **점유 대기 (Hold and Wait)** | 자원을 가지고 있으면서, 다른 자원을 기다림 |
| **비선점 (No Preemption)** | 할당된 자원을 강제로 빼앗을 수 없음 |
| **환형 대기 (Circular Wait)** | 각 프로세스가 다음 자원을 기다리며 순환 구조를 이룸 |

- 위 조건이 모두 만족해야만 교착 상태가 발생함
- 교착 상태를 피하기 위해서는 위 조건 중 하나라도 만족하지 않도록 해야 함


> 아직 완벽하게 교착상태를 막을 수 있는 방법은 없음...


### 기아상태 (Starvation)
> 프로세스의 우선 순위가 낮아서 원하는 자원을 계속 받지 못해 대기하는 상태


### 해결 방법
- 프로세스의 우선 순위를 조정하여 기아 상태를 방지하는 방법
- 프로세스의 우선 순위를 낮추어 교착 상태를 방지하는 방법
- 오래 대기한 프로세스의 우선 순위를 높여주는 방법


# 3. 메모리

## 메모리 관리의 개념
### 메모리 관리란?
프로그램들이 잘 실행될 수 있도록 메모리를 할당하고, 해제하는 작업

- 각 프로그램의 리소스를 보호해야 한다.
- 여러 프로세스가 동시에 실행될 수 있도록 메모리 공간을 제공해야 한다.


### 🧠 메모리 주소 (Memory Address)
- 메모리는 바이트 단위로 구분되며, 각 바이트는 고유한 주소(번호)를 가짐
- CPU가 데이터를 읽고 쓸 때 이 주소를 이용함
- 대표적인 주소 방식
  - **물리 주소(Physical Address)** : 실제 메모리 하드웨어 상의 주소
  - **논리 주소(Logical Address)** : 프로그램이 사용하는 주소 (컴파일러/OS가 물리 주소로 매핑)


### 🗂️ 메모리 할당 (Memory Allocation)
- 프로그램이 실행될 때, 필요한 메모리를 확보하는 과정
- **정적 할당 (Static Allocation)** : 컴파일 시 메모리 크기와 위치가 결정됨  
  (예: 전역 변수, static 변수 등)
- **동적 할당 (Dynamic Allocation)** : 실행 중에 메모리 할당  
  (예: `malloc`, `new` 등)
- **스택(Stack)** : 함수 호출 시 임시 데이터 저장  
  (지역 변수, 리턴 주소 등)
- **힙(Heap)** : 사용자가 직접 요청하여 사용하는 동적 메모리 영역


### 🧹 메모리 해제 (Memory Release)
- 사용이 끝난 메모리를 다시 시스템에 반환하는 과정
- 수동 해제: 프로그래머가 명시적으로 해제  
  (예: C 언어의 `free()`, C++의 `delete`)
- 자동 해제: 가비지 컬렉터가 알아서 회수  
  (예: Python, Java의 GC)
- 해제를 안 하면? → **메모리 누수(Memory Leak)** 발생 가능


### 연속 할당과 불연속 할당
- **연속 할당(Contiguous Allocation)** : 메모리를 연속적으로 할당하는 방식
  - 장점: 단순하고 빠름
  - 단점: 메모리 단편화 발생 가능 (Fragmentation)

- **불연속 할당(Non-contiguous Allocation)** : 메모리를 불연속적으로 할당하는 방식
  - 장점: 메모리 단편화 문제 해결 가능
  - 단점: 관리가 복잡하고 느림


### 고정 분할 방식
- 메모리를 고정된 크기로 나누어 할당하는 방식
- 각 프로세스는 고정된 크기의 메모리 블록을 할당받음
- 장점: 단순하고 빠름
- 단점: 내부 단편화 발생 가능

> 내부 단편화 : 할당된 메모리 블록이 사용되지 않는 부분이 생기는 현상


### 가변 분할 방식
- 메모리를 가변 크기로 나누어 할당하는 방식
- 각 프로세스는 필요한 만큼의 메모리를 할당받음
- 장점: 메모리 공간을 효율적으로 사용 가능
- 단점: 외부 단편화 발생 가능

> 외부 단편화 : 할당된 메모리 블록 사이에 사용되지 않는 공간이 생기는 현상


## 가상 메모리
```
실제 물리적 주소가 아닌 가상의 주소인 논리적 주소를 프로세스가 사용하도록 하는 기술
```

- 모든 프로세스가 고정된 주소를 가질 수 있도록 한다.
- 실제 물리적인 주소는 운영체제만 접근할 수 있어 보안성이 높다.
- 보조 기억 장치 일부를 가상 메모리로 사용하여 실제 메모리보다 큰 주소 공간을 제공한다.


### 논리적 주소와 물리적 주소
| 구분               | 설명                                                                 |
|--------------------|----------------------------------------------------------------------|
| 논리적 주소 (Logical Address) | - 프로세스가 사용하는 주소 (가상 주소)  <br> - CPU가 생성하며, 사용자 입장에서는 이 주소만 보임 <br> - 프로그램 입장에서는 0번지부터 시작 |
| 물리적 주소 (Physical Address) | - 실제 메모리(RAM)에 저장된 주소 <br> - MMU(메모리 관리 장치)가 논리적 주소를 변환해서 결정 <br> - 운영체제가 직접 관리 |




## 페이징(Paging)
### 페이지 (Page)
```
물리적 메모리와 가상 주소를 연결하는 단위
```

- 가상 주소와 물리적 주소를 매핑하는 단위
- 일반적으로 4KB 또는 8KB 크기
- 페이지는 고정된 크기로 나누어져 있으며, 페이지 테이블을 통해 매핑됨


### 페이지 테이블 (Page Table)
> 가상 메모리의 페이지와 물리 메모리를 매핑하는 표


### 스와핑 (Swapping)
> 안 쓰는 프로세스는 잠시 하드 디스크에 넣어두기


### 프로세스 스와핑
- 프로세스 단위로 메모리와 하드 디스크를 전환하는 것은 비효율, 단편화 발생
- 최근에는 사용 X


### 캐시 (Cache)
> 데이터나 값을 미리 복사해놓는 임시 장소

- 자주 사용되는 데이터를 미리 복사해놓고 빠르게 접근할 수 있도록 하는 메모리
- 모든 데이터를 캐시할 수는 없으므로, 자주 사용되는 데이터만 캐시함


### 요구 페이징 (Demand Paging)
> 페이지 단위로 스와핑하여 당장 필요한 페이지만 메모리에 남겨두는 방법

- 실제 물리 메모리를 하드 디스크의 캐시로 사용하는 기법
- 일정한 크기로 자르기 때문에 **내부 단편화** 가 발생




## 세그멘테이션(Segmentation)

### 세그멘테이션
```
논리적으로 같은 역활을 하는 부분끼리 자르는 방법
```

### 장점
1. 중요한 부분과 그렇지 않은 부분을 분리할 수 있어서 효율적
2. 같은 코드 영역은 하나만 저장하고 같은 곳을 가리키도록 하면 중복된 내용을 없앨 수 있음
3. 내부 단편화 문제가 해결됨


### 단점
1. 외부 단편화 발생 가능
2. 외부 단편화가 내부 단편화보다 큰 공간이 낭비됨
3. 페이지 테이블과 세그먼트 테이블을 모두 관리해야 함

### 페이징 + 세그멘테이션
- 페이징과 세그멘테이션을 결합하여 사용
- 세그먼트 테이블을 사용하여 각 세그먼트의 페이지 테이블을 관리함
- 세그먼트의 장점을 살리고, 페이징의 단점을 보완함
- 테이블을 두 개 관리해야 하므로 복잡함

# 4. 파일 시스템

## 파일과 파일 시스템
### 파일 (file)이란?
컴퓨터에서 정보를 담는 논리적인 저장 단위

- 파일은 비휘발성 기억장치에 저장되어 있다.


#### 파일 메타데이터 (files's metadata)
파일을 관리하기 위한 정보들

- 파일 이름, 크기, 생성일자, 수정일자, 접근 권한 등


### 디렉터리 (directory)
```
파일에 대한 여러 정보를 가지고 있는 특수한 파일
```

- 해당 디렉터리에 속한 파일의 이름과 속성들을 포함하고 있음


### 파일 시스템 (file system)
```
파일들을 쉽게 접근할 수 있도록 관리하는 체제
```

- 파일 시스템은 크게 디스크, 네트워크, 그리고 특수 용도의 파일 시스템으로 나뉨



## 디스크 할당
### 순차 접근 저장장치
- 앞에서부터 순서대로 읽어야 하는 저장 장치
- 원하는 지점을 찾기 어렵고 빨리 감기와 되감기 기능이 필요하다

### 직접 접근 저장장치
- 헤드를 옮겨 원하는 부분부터 접근이 가능
- 모든 데이터를 읽지 않고도 바로 원하는 곳에 접근이 가능


### 하드 디스크
- 하드 디스크는 직접 접근 저장 장치로, 물리적으로 회전하는 디스크에 데이터를 저장함

#### SSD
- SSD는 반도체 메모리로, 하드 디스크보다 빠른 속도로 데이터를 읽고 쓸 수 있음
- SSD는 전원이 꺼져도 데이터가 유지됨
- SSD는 하드 디스크보다 가격이 비쌈


### 파일 할당
- 파일을 저장할 때, 디스크의 어느 위치에 저장할 것인지 결정하는 과정
- 파일 할당 방식은 크게 연속 할당, 연결 할당, 색인 할당으로 나뉨


#### 연속 할당 (Contiguous Allocation)
- 앞에서부터 순서대로 저장하는 방식
- 장점: 빠른 접근 속도
- 단점: 외부 단편화 발생 가능


#### 연결 할당 (Linked Allocation)
- 각 블록이 다음 블록의 주소를 가리키는 방식
- 장점: 외부 단편화 문제 해결 가능
- 단점: 접근 속도가 느림, 중간에 블록이 손상되면 복구가 어려움


#### FAT (File Allocation Table)
- 연결 할당 방식의 일종으로, 파일의 시작 블록과 다음 블록의 주소를 저장하는 테이블
- 장점: 외부 단편화 문제 해결 가능, 빠른 접근 속도
- 단점: 테이블 크기가 커질 수 있음


#### 색인 할당 (Indexed Allocation)
- 각 파일에 대한 색인 블록을 만들어 해당 블록에 파일의 모든 블록 주소를 저장하는 방식
- 장점: 외부 단편화 문제 해결 가능, 빠른 접근 속도
- 단점: 색인 블록이 손상되면 복구가 어려움, 색인 블록 크기가 커질 수 있음




## 🔗 링크 (Link)
링크는 **파일이나 디렉토리에 대한 참조(별명)** 를 만들어주는 기능입니다.


### 📁 종류

| 종류 | 설명 | 비유 |
|------|------|------|
| **하드 링크 (Hard Link)** | 원본 파일과 동일한 데이터 블록을 가리킴 | 같은 문서를 다른 폴더에도 저장한 느낌 |
| **심볼릭 링크 (Soft Link)** | 원본 파일의 경로를 가리키는 포인터 | "여기 말고 저기 있어요!"라고 가리키는 표지판 |

### 🔍 차이점 비교

| 비교 항목 | 하드 링크 | 심볼릭 링크 |
|------------|-----------|---------------|
| 원리 | 파일의 실제 데이터 블록을 공유 | 파일의 경로를 저장 |
| 원본 삭제 시 | 여전히 접근 가능 | 링크 깨짐 (dangling) |
| 파일 시스템 제약 | 같은 파일 시스템 내에서만 가능 | 다른 파일 시스템도 가능 |
| 디렉토리 링크 | 일반적으로 제한됨 | 가능 (주의 필요) |



## 📦 마운트 (Mount)
마운트는 외부 저장장치나 파일 시스템을 현재 디렉터리 구조에 연결하는 작업입니다.

#### 🧭 쉽게 말하면?
USB를 꽂았을 때 /media/usb 같은 경로가 생기죠?
이게 바로 '마운트'된 상태입니다.


### 📚 주요 개념

| 용어 | 설명 |
|------|------|
| **마운트 포인트 (Mount Point)** | 외부 장치를 연결할 디렉토리 위치 (예: `/mnt/usb`) |
| **파일 시스템 (File System)** | 데이터를 저장하고 읽는 방식 (ext4, NTFS, FAT32 등) |
| **언마운트 (Unmount)** | 마운트된 장치 연결을 해제하는 작업 |